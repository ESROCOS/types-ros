-- Generated from package.asn.mako for package sensor_msgs

Sensor-msgs-Types DEFINITIONS ::=
BEGIN

IMPORTS
T-Boolean, T-Int8, T-UInt8, T-Int32, T-UInt32 FROM TASTE-BasicTypes
T-Int16, T-UInt16, T-Int64, T-UInt64, T-Float, T-Double, T-String, T-Time FROM TASTE-ExtendedTypes
Geometry-msgs-Point32, Geometry-msgs-Vector3, Geometry-msgs-Transform, Geometry-msgs-Twist, Geometry-msgs-Quaternion, Geometry-msgs-Wrench FROM Geometry-msgs-Types
Std-msgs-Header FROM Std-msgs-Types
max-Sensor-msgs-CameraInfo, max-Sensor-msgs-Joy, max-Sensor-msgs-Image, max-Sensor-msgs-LaserScan, max-Sensor-msgs-MultiEchoLaserScan, max-Sensor-msgs-JointState, max-Sensor-msgs-JoyFeedbackArray, max-Sensor-msgs-BatteryState, max-Sensor-msgs-LaserEcho, max-Sensor-msgs-ChannelFloat32, max-Sensor-msgs-CompressedImage, max-Sensor-msgs-PointCloud, max-Sensor-msgs-PointCloud2, max-Sensor-msgs-MultiDOFJointState, Dummy-Sensor-msgs-Types-T FROM UserDefs-Sensor-msgs-Types;
    -- ================================================================================
    -- Message Sensor-msgs-Types/BatteryState
    -- ================================================================================
    -- 
    -- # Constants are chosen to match the enums in the linux kernel
    -- # defined in include/linux/power_supply.h as of version 3.7
    -- # The one difference is for style reasons the constants are
    -- # all uppercase not mixed case.
    -- 
    -- # Power supply status constants
    -- uint8 POWER_SUPPLY_STATUS_UNKNOWN = 0
    -- uint8 POWER_SUPPLY_STATUS_CHARGING = 1
    -- uint8 POWER_SUPPLY_STATUS_DISCHARGING = 2
    -- uint8 POWER_SUPPLY_STATUS_NOT_CHARGING = 3
    -- uint8 POWER_SUPPLY_STATUS_FULL = 4
    -- 
    -- # Power supply health constants
    -- uint8 POWER_SUPPLY_HEALTH_UNKNOWN = 0
    -- uint8 POWER_SUPPLY_HEALTH_GOOD = 1
    -- uint8 POWER_SUPPLY_HEALTH_OVERHEAT = 2
    -- uint8 POWER_SUPPLY_HEALTH_DEAD = 3
    -- uint8 POWER_SUPPLY_HEALTH_OVERVOLTAGE = 4
    -- uint8 POWER_SUPPLY_HEALTH_UNSPEC_FAILURE = 5
    -- uint8 POWER_SUPPLY_HEALTH_COLD = 6
    -- uint8 POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE = 7
    -- uint8 POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE = 8
    -- 
    -- # Power supply technology (chemistry) constants
    -- uint8 POWER_SUPPLY_TECHNOLOGY_UNKNOWN = 0
    -- uint8 POWER_SUPPLY_TECHNOLOGY_NIMH = 1
    -- uint8 POWER_SUPPLY_TECHNOLOGY_LION = 2
    -- uint8 POWER_SUPPLY_TECHNOLOGY_LIPO = 3
    -- uint8 POWER_SUPPLY_TECHNOLOGY_LIFE = 4
    -- uint8 POWER_SUPPLY_TECHNOLOGY_NICD = 5
    -- uint8 POWER_SUPPLY_TECHNOLOGY_LIMN = 6
    -- 
    -- Header  header
    -- float32 voltage          # Voltage in Volts (Mandatory)
    -- float32 current          # Negative when discharging (A)  (If unmeasured NaN)
    -- float32 charge           # Current charge in Ah  (If unmeasured NaN)
    -- float32 capacity         # Capacity in Ah (last full capacity)  (If unmeasured NaN)
    -- float32 design_capacity  # Capacity in Ah (design capacity)  (If unmeasured NaN)
    -- float32 percentage       # Charge percentage on 0 to 1 range  (If unmeasured NaN)
    -- uint8   power_supply_status     # The charging status as reported. Values defined above
    -- uint8   power_supply_health     # The battery health metric. Values defined above
    -- uint8   power_supply_technology # The battery chemistry. Values defined above
    -- bool    present          # True if the battery is present
    -- 
    -- float32[] cell_voltage   # An array of individual cell voltages for each cell in the pack
    --                          # If individual voltages unknown but number of cells known set each to NaN
    -- string location          # The location into which the battery is inserted. (slot number or plug)
    -- string serial_number     # The best approximation of the battery serial number
    -- 
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/BatteryState
    Sensor-msgs-BatteryState ::= SEQUENCE
    {
        header Std-msgs-Header,
        voltage T-Float,
        current T-Float,
        charge T-Float,
        capacity T-Float,
        design-capacity T-Float,
        percentage T-Float,
        power-supply-status T-UInt8,
        power-supply-health T-UInt8,
        power-supply-technology T-UInt8,
        present T-Boolean,
        cell-voltage SEQUENCE (SIZE(0..max-Sensor-msgs-BatteryState)) OF T-Float,
        location T-String,
        serial-number T-String
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/CameraInfo
    -- ================================================================================
    -- # This message defines meta information for a camera. It should be in a
    -- # camera namespace on topic "camera_info" and accompanied by up to five
    -- # image topics named:
    -- #
    -- #   image_raw - raw data from the camera driver, possibly Bayer encoded
    -- #   image            - monochrome, distorted
    -- #   image_color      - color, distorted
    -- #   image_rect       - monochrome, rectified
    -- #   image_rect_color - color, rectified
    -- #
    -- # The image_pipeline contains packages (image_proc, stereo_image_proc)
    -- # for producing the four processed image topics from image_raw and
    -- # camera_info. The meaning of the camera parameters are described in
    -- # detail at http://www.ros.org/wiki/image_pipeline/CameraInfo.
    -- #
    -- # The image_geometry package provides a user-friendly interface to
    -- # common operations using this meta information. If you want to, e.g.,
    -- # project a 3d point into image coordinates, we strongly recommend
    -- # using image_geometry.
    -- #
    -- # If the camera is uncalibrated, the matrices D, K, R, P should be left
    -- # zeroed out. In particular, clients may assume that K[0] == 0.0
    -- # indicates an uncalibrated camera.
    -- 
    -- #######################################################################
    -- #                     Image acquisition info                          #
    -- #######################################################################
    -- 
    -- # Time of image acquisition, camera coordinate frame ID
    -- Header header    # Header timestamp should be acquisition time of image
    --                  # Header frame_id should be optical frame of camera
    --                  # origin of frame should be optical center of camera
    --                  # +x should point to the right in the image
    --                  # +y should point down in the image
    --                  # +z should point into the plane of the image
    -- 
    -- 
    -- #######################################################################
    -- #                      Calibration Parameters                         #
    -- #######################################################################
    -- # These are fixed during camera calibration. Their values will be the #
    -- # same in all messages until the camera is recalibrated. Note that    #
    -- # self-calibrating systems may "recalibrate" frequently.              #
    -- #                                                                     #
    -- # The internal parameters can be used to warp a raw (distorted) image #
    -- # to:                                                                 #
    -- #   1. An undistorted image (requires D and K)                        #
    -- #   2. A rectified image (requires D, K, R)                           #
    -- # The projection matrix P projects 3D points into the rectified image.#
    -- #######################################################################
    -- 
    -- # The image dimensions with which the camera was calibrated. Normally
    -- # this will be the full camera resolution in pixels.
    -- uint32 height
    -- uint32 width
    -- 
    -- # The distortion model used. Supported models are listed in
    -- # sensor_msgs/distortion_models.h. For most cameras, "plumb_bob" - a
    -- # simple model of radial and tangential distortion - is sufficient.
    -- string distortion_model
    -- 
    -- # The distortion parameters, size depending on the distortion model.
    -- # For "plumb_bob", the 5 parameters are: (k1, k2, t1, t2, k3).
    -- float64[] D
    -- 
    -- # Intrinsic camera matrix for the raw (distorted) images.
    -- #     [fx  0 cx]
    -- # K = [ 0 fy cy]
    -- #     [ 0  0  1]
    -- # Projects 3D points in the camera coordinate frame to 2D pixel
    -- # coordinates using the focal lengths (fx, fy) and principal point
    -- # (cx, cy).
    -- float64[9]  K # 3x3 row-major matrix
    -- 
    -- # Rectification matrix (stereo cameras only)
    -- # A rotation matrix aligning the camera coordinate system to the ideal
    -- # stereo image plane so that epipolar lines in both stereo images are
    -- # parallel.
    -- float64[9]  R # 3x3 row-major matrix
    -- 
    -- # Projection/camera matrix
    -- #     [fx'  0  cx' Tx]
    -- # P = [ 0  fy' cy' Ty]
    -- #     [ 0   0   1   0]
    -- # By convention, this matrix specifies the intrinsic (camera) matrix
    -- #  of the processed (rectified) image. That is, the left 3x3 portion
    -- #  is the normal camera intrinsic matrix for the rectified image.
    -- # It projects 3D points in the camera coordinate frame to 2D pixel
    -- #  coordinates using the focal lengths (fx', fy') and principal point
    -- #  (cx', cy') - these may differ from the values in K.
    -- # For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will
    -- #  also have R = the identity and P[1:3,1:3] = K.
    -- # For a stereo pair, the fourth column [Tx Ty 0]' is related to the
    -- #  position of the optical center of the second camera in the first
    -- #  camera's frame. We assume Tz = 0 so both cameras are in the same
    -- #  stereo image plane. The first camera always has Tx = Ty = 0. For
    -- #  the right (second) camera of a horizontal stereo pair, Ty = 0 and
    -- #  Tx = -fx' * B, where B is the baseline between the cameras.
    -- # Given a 3D point [X Y Z]', the projection (x, y) of the point onto
    -- #  the rectified image is given by:
    -- #  [u v w]' = P * [X Y Z 1]'
    -- #         x = u / w
    -- #         y = v / w
    -- #  This holds for both images of a stereo pair.
    -- float64[12] P # 3x4 row-major matrix
    -- 
    -- 
    -- #######################################################################
    -- #                      Operational Parameters                         #
    -- #######################################################################
    -- # These define the image region actually captured by the camera       #
    -- # driver. Although they affect the geometry of the output image, they #
    -- # may be changed freely without recalibrating the camera.             #
    -- #######################################################################
    -- 
    -- # Binning refers here to any camera setting which combines rectangular
    -- #  neighborhoods of pixels into larger "super-pixels." It reduces the
    -- #  resolution of the output image to
    -- #  (width / binning_x) x (height / binning_y).
    -- # The default values binning_x = binning_y = 0 is considered the same
    -- #  as binning_x = binning_y = 1 (no subsampling).
    -- uint32 binning_x
    -- uint32 binning_y
    -- 
    -- # Region of interest (subwindow of full camera resolution), given in
    -- #  full resolution (unbinned) image coordinates. A particular ROI
    -- #  always denotes the same window of pixels on the camera sensor,
    -- #  regardless of binning settings.
    -- # The default setting of roi (all values 0) is considered the same as
    -- #  full resolution (roi.width = width, roi.height = height).
    -- RegionOfInterest roi
    -- 
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- 
    -- ================================================================================
    -- MSG: sensor_msgs/RegionOfInterest
    -- # This message is used to specify a region of interest within an image.
    -- #
    -- # When used to specify the ROI setting of the camera when the image was
    -- # taken, the height and width fields should either match the height and
    -- # width fields for the associated image; or height = width = 0
    -- # indicates that the full resolution image was captured.
    -- 
    -- uint32 x_offset  # Leftmost pixel of the ROI
    --                  # (0 if the ROI includes the left edge of the image)
    -- uint32 y_offset  # Topmost pixel of the ROI
    --                  # (0 if the ROI includes the top edge of the image)
    -- uint32 height    # Height of ROI
    -- uint32 width     # Width of ROI
    -- 
    -- # True if a distinct rectified ROI should be calculated from the "raw"
    -- # ROI in this message. Typically this should be False if the full image
    -- # is captured (ROI not used), and True if a subwindow is captured (ROI
    -- # used).
    -- bool do_rectify
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/CameraInfo
    Sensor-msgs-CameraInfo ::= SEQUENCE
    {
        header Std-msgs-Header,
        height T-UInt32,
        width T-UInt32,
        distortion-model T-String,
        d SEQUENCE (SIZE(0..max-Sensor-msgs-CameraInfo)) OF T-Double,
        k SEQUENCE (SIZE(9)) OF T-Double,
        r SEQUENCE (SIZE(9)) OF T-Double,
        p SEQUENCE (SIZE(12)) OF T-Double,
        binning-x T-UInt32,
        binning-y T-UInt32,
        roi Sensor-msgs-RegionOfInterest
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/ChannelFloat32
    -- ================================================================================
    -- # This message is used by the PointCloud message to hold optional data
    -- # associated with each point in the cloud. The length of the values
    -- # array should be the same as the length of the points array in the
    -- # PointCloud, and each value should be associated with the corresponding
    -- # point.
    -- 
    -- # Channel names in existing practice include:
    -- #   "u", "v" - row and column (respectively) in the left stereo image.
    -- #              This is opposite to usual conventions but remains for
    -- #              historical reasons. The newer PointCloud2 message has no
    -- #              such problem.
    -- #   "rgb" - For point clouds produced by color stereo cameras. uint8
    -- #           (R,G,B) values packed into the least significant 24 bits,
    -- #           in order.
    -- #   "intensity" - laser or pixel intensity.
    -- #   "distance"
    -- 
    -- # The channel name should give semantics of the channel (e.g.
    -- # "intensity" instead of "value").
    -- string name
    -- 
    -- # The values array should be 1-1 with the elements of the associated
    -- # PointCloud.
    -- float32[] values
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/ChannelFloat32
    Sensor-msgs-ChannelFloat32 ::= SEQUENCE
    {
        name-value T-String,
        values SEQUENCE (SIZE(0..max-Sensor-msgs-ChannelFloat32)) OF T-Float
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/CompressedImage
    -- ================================================================================
    -- # This message contains a compressed image
    -- 
    -- Header header        # Header timestamp should be acquisition time of image
    --                      # Header frame_id should be optical frame of camera
    --                      # origin of frame should be optical center of cameara
    --                      # +x should point to the right in the image
    --                      # +y should point down in the image
    --                      # +z should point into to plane of the image
    -- 
    -- string format        # Specifies the format of the data
    --                      #   Acceptable values:
    --                      #     jpeg, png
    -- uint8[] data         # Compressed image buffer
    -- 
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/CompressedImage
    Sensor-msgs-CompressedImage ::= SEQUENCE
    {
        header Std-msgs-Header,
        format T-String,
        data-value OCTET STRING (SIZE(0..max-Sensor-msgs-CompressedImage))
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/FluidPressure
    -- ================================================================================
    --  # Single pressure reading.  This message is appropriate for measuring the
    --  # pressure inside of a fluid (air, water, etc).  This also includes
    --  # atmospheric or barometric pressure.
    -- 
    --  # This message is not appropriate for force/pressure contact sensors.
    -- 
    --  Header header           # timestamp of the measurement
    --                          # frame_id is the location of the pressure sensor
    -- 
    --  float64 fluid_pressure  # Absolute pressure reading in Pascals.
    -- 
    --  float64 variance        # 0 is interpreted as variance unknown
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/FluidPressure
    Sensor-msgs-FluidPressure ::= SEQUENCE
    {
        header Std-msgs-Header,
        fluid-pressure T-Double,
        variance T-Double
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/Illuminance
    -- ================================================================================
    --  # Single photometric illuminance measurement.  Light should be assumed to be
    --  # measured along the sensor's x-axis (the area of detection is the y-z plane).
    --  # The illuminance should have a 0 or positive value and be received with
    --  # the sensor's +X axis pointing toward the light source.
    -- 
    --  # Photometric illuminance is the measure of the human eye's sensitivity of the
    --  # intensity of light encountering or passing through a surface.
    -- 
    --  # All other Photometric and Radiometric measurements should
    --  # not use this message.
    --  # This message cannot represent:
    --  # Luminous intensity (candela/light source output)
    --  # Luminance (nits/light output per area)
    --  # Irradiance (watt/area), etc.
    -- 
    --  Header header           # timestamp is the time the illuminance was measured
    --                          # frame_id is the location and direction of the reading
    -- 
    --  float64 illuminance     # Measurement of the Photometric Illuminance in Lux.
    -- 
    --  float64 variance        # 0 is interpreted as variance unknown
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/Illuminance
    Sensor-msgs-Illuminance ::= SEQUENCE
    {
        header Std-msgs-Header,
        illuminance T-Double,
        variance T-Double
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/Image
    -- ================================================================================
    -- # This message contains an uncompressed image
    -- # (0, 0) is at top-left corner of image
    -- #
    -- 
    -- Header header        # Header timestamp should be acquisition time of image
    --                      # Header frame_id should be optical frame of camera
    --                      # origin of frame should be optical center of cameara
    --                      # +x should point to the right in the image
    --                      # +y should point down in the image
    --                      # +z should point into to plane of the image
    --                      # If the frame_id here and the frame_id of the CameraInfo
    --                      # message associated with the image conflict
    --                      # the behavior is undefined
    -- 
    -- uint32 height         # image height, that is, number of rows
    -- uint32 width          # image width, that is, number of columns
    -- 
    -- # The legal values for encoding are in file src/image_encodings.cpp
    -- # If you want to standardize a new string format, join
    -- # ros-users@lists.sourceforge.net and send an email proposing a new encoding.
    -- 
    -- string encoding       # Encoding of pixels -- channel meaning, ordering, size
    --                       # taken from the list of strings in include/sensor_msgs/image_encodings.h
    -- 
    -- uint8 is_bigendian    # is this data bigendian?
    -- uint32 step           # Full row length in bytes
    -- uint8[] data          # actual matrix data, size is (step * rows)
    -- 
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/Image
    Sensor-msgs-Image ::= SEQUENCE
    {
        header Std-msgs-Header,
        height T-UInt32,
        width T-UInt32,
        encoding T-String,
        is-bigendian T-UInt8,
        step T-UInt32,
        data-value OCTET STRING (SIZE(0..max-Sensor-msgs-Image))
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/Imu
    -- ================================================================================
    -- # This is a message to hold data from an IMU (Inertial Measurement Unit)
    -- #
    -- # Accelerations should be in m/s^2 (not in g's), and rotational velocity should be in rad/sec
    -- #
    -- # If the covariance of the measurement is known, it should be filled in (if all you know is the 
    -- # variance of each measurement, e.g. from the datasheet, just put those along the diagonal)
    -- # A covariance matrix of all zeros will be interpreted as "covariance unknown", and to use the
    -- # data a covariance will have to be assumed or gotten from some other source
    -- #
    -- # If you have no estimate for one of the data elements (e.g. your IMU doesn't produce an orientation 
    -- # estimate), please set element 0 of the associated covariance matrix to -1
    -- # If you are interpreting this message, please check for a value of -1 in the first element of each 
    -- # covariance matrix, and disregard the associated estimate.
    -- 
    -- Header header
    -- 
    -- geometry_msgs/Quaternion orientation
    -- float64[9] orientation_covariance # Row major about x, y, z axes
    -- 
    -- geometry_msgs/Vector3 angular_velocity
    -- float64[9] angular_velocity_covariance # Row major about x, y, z axes
    -- 
    -- geometry_msgs/Vector3 linear_acceleration
    -- float64[9] linear_acceleration_covariance # Row major x, y z 
    -- 
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- 
    -- ================================================================================
    -- MSG: geometry_msgs/Quaternion
    -- # This represents an orientation in free space in quaternion form.
    -- 
    -- float64 x
    -- float64 y
    -- float64 z
    -- float64 w
    -- 
    -- ================================================================================
    -- MSG: geometry_msgs/Vector3
    -- # This represents a vector in free space. 
    -- # It is only meant to represent a direction. Therefore, it does not
    -- # make sense to apply a translation to it (e.g., when applying a 
    -- # generic rigid transformation to a Vector3, tf2 will only apply the
    -- # rotation). If you want your data to be translatable too, use the
    -- # geometry_msgs/Point message instead.
    -- 
    -- float64 x
    -- float64 y
    -- float64 z    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/Imu
    Sensor-msgs-Imu ::= SEQUENCE
    {
        header Std-msgs-Header,
        orientation Geometry-msgs-Quaternion,
        orientation-covariance SEQUENCE (SIZE(9)) OF T-Double,
        angular-velocity Geometry-msgs-Vector3,
        angular-velocity-covariance SEQUENCE (SIZE(9)) OF T-Double,
        linear-acceleration Geometry-msgs-Vector3,
        linear-acceleration-covariance SEQUENCE (SIZE(9)) OF T-Double
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/JointState
    -- ================================================================================
    -- # This is a message that holds data to describe the state of a set of torque controlled joints. 
    -- #
    -- # The state of each joint (revolute or prismatic) is defined by:
    -- #  * the position of the joint (rad or m),
    -- #  * the velocity of the joint (rad/s or m/s) and 
    -- #  * the effort that is applied in the joint (Nm or N).
    -- #
    -- # Each joint is uniquely identified by its name
    -- # The header specifies the time at which the joint states were recorded. All the joint states
    -- # in one message have to be recorded at the same time.
    -- #
    -- # This message consists of a multiple arrays, one for each part of the joint state. 
    -- # The goal is to make each of the fields optional. When e.g. your joints have no
    -- # effort associated with them, you can leave the effort array empty. 
    -- #
    -- # All arrays in this message should have the same size, or be empty.
    -- # This is the only way to uniquely associate the joint name with the correct
    -- # states.
    -- 
    -- 
    -- Header header
    -- 
    -- string[] name
    -- float64[] position
    -- float64[] velocity
    -- float64[] effort
    -- 
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/JointState
    Sensor-msgs-JointState ::= SEQUENCE
    {
        header Std-msgs-Header,
        name-value SEQUENCE (SIZE(0..max-Sensor-msgs-JointState)) OF T-String,
        position SEQUENCE (SIZE(0..max-Sensor-msgs-JointState)) OF T-Double,
        velocity SEQUENCE (SIZE(0..max-Sensor-msgs-JointState)) OF T-Double,
        effort SEQUENCE (SIZE(0..max-Sensor-msgs-JointState)) OF T-Double
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/Joy
    -- ================================================================================
    -- # Reports the state of a joysticks axes and buttons.
    -- Header header           # timestamp in the header is the time the data is received from the joystick
    -- float32[] axes          # the axes measurements from a joystick
    -- int32[] buttons         # the buttons measurements from a joystick 
    -- 
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/Joy
    Sensor-msgs-Joy ::= SEQUENCE
    {
        header Std-msgs-Header,
        axes SEQUENCE (SIZE(0..max-Sensor-msgs-Joy)) OF T-Float,
        buttons SEQUENCE (SIZE(0..max-Sensor-msgs-Joy)) OF T-Int32
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/JoyFeedback
    -- ================================================================================
    -- # Declare of the type of feedback
    -- uint8 TYPE_LED    = 0
    -- uint8 TYPE_RUMBLE = 1
    -- uint8 TYPE_BUZZER = 2
    -- 
    -- uint8 type
    -- 
    -- # This will hold an id number for each type of each feedback.
    -- # Example, the first led would be id=0, the second would be id=1
    -- uint8 id
    -- 
    -- # Intensity of the feedback, from 0.0 to 1.0, inclusive.  If device is
    -- # actually binary, driver should treat 0<=x<0.5 as off, 0.5<=x<=1 as on.
    -- float32 intensity
    -- 
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/JoyFeedback
    Sensor-msgs-JoyFeedback ::= SEQUENCE
    {
        type-value T-UInt8,
        id T-UInt8,
        intensity T-Float
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/JoyFeedbackArray
    -- ================================================================================
    -- # This message publishes values for multiple feedback at once. 
    -- JoyFeedback[] array
    -- ================================================================================
    -- MSG: sensor_msgs/JoyFeedback
    -- # Declare of the type of feedback
    -- uint8 TYPE_LED    = 0
    -- uint8 TYPE_RUMBLE = 1
    -- uint8 TYPE_BUZZER = 2
    -- 
    -- uint8 type
    -- 
    -- # This will hold an id number for each type of each feedback.
    -- # Example, the first led would be id=0, the second would be id=1
    -- uint8 id
    -- 
    -- # Intensity of the feedback, from 0.0 to 1.0, inclusive.  If device is
    -- # actually binary, driver should treat 0<=x<0.5 as off, 0.5<=x<=1 as on.
    -- float32 intensity
    -- 
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/JoyFeedbackArray
    Sensor-msgs-JoyFeedbackArray ::= SEQUENCE (SIZE(0..max-Sensor-msgs-JoyFeedbackArray)) OF Sensor-msgs-JoyFeedback
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/LaserEcho
    -- ================================================================================
    -- # This message is a submessage of MultiEchoLaserScan and is not intended
    -- # to be used separately.
    -- 
    -- float32[] echoes  # Multiple values of ranges or intensities.
    --                   # Each array represents data from the same angle increment.    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/LaserEcho
    Sensor-msgs-LaserEcho ::= SEQUENCE (SIZE(0..max-Sensor-msgs-LaserEcho)) OF T-Float
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/LaserScan
    -- ================================================================================
    -- # Single scan from a planar laser range-finder
    -- #
    -- # If you have another ranging device with different behavior (e.g. a sonar
    -- # array), please find or create a different message, since applications
    -- # will make fairly laser-specific assumptions about this data
    -- 
    -- Header header            # timestamp in the header is the acquisition time of 
    --                          # the first ray in the scan.
    --                          #
    --                          # in frame frame_id, angles are measured around 
    --                          # the positive Z axis (counterclockwise, if Z is up)
    --                          # with zero angle being forward along the x axis
    --                          
    -- float32 angle_min        # start angle of the scan [rad]
    -- float32 angle_max        # end angle of the scan [rad]
    -- float32 angle_increment  # angular distance between measurements [rad]
    -- 
    -- float32 time_increment   # time between measurements [seconds] - if your scanner
    --                          # is moving, this will be used in interpolating position
    --                          # of 3d points
    -- float32 scan_time        # time between scans [seconds]
    -- 
    -- float32 range_min        # minimum range value [m]
    -- float32 range_max        # maximum range value [m]
    -- 
    -- float32[] ranges         # range data [m] (Note: values < range_min or > range_max should be discarded)
    -- float32[] intensities    # intensity data [device-specific units].  If your
    --                          # device does not provide intensities, please leave
    --                          # the array empty.
    -- 
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/LaserScan
    Sensor-msgs-LaserScan ::= SEQUENCE
    {
        header Std-msgs-Header,
        angle-min T-Float,
        angle-max T-Float,
        angle-increment T-Float,
        time-increment T-Float,
        scan-time T-Float,
        range-min T-Float,
        range-max T-Float,
        ranges SEQUENCE (SIZE(0..max-Sensor-msgs-LaserScan)) OF T-Float,
        intensities SEQUENCE (SIZE(0..max-Sensor-msgs-LaserScan)) OF T-Float
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/MagneticField
    -- ================================================================================
    --  # Measurement of the Magnetic Field vector at a specific location.
    -- 
    --  # If the covariance of the measurement is known, it should be filled in
    --  # (if all you know is the variance of each measurement, e.g. from the datasheet,
    --  #just put those along the diagonal)
    --  # A covariance matrix of all zeros will be interpreted as "covariance unknown",
    --  # and to use the data a covariance will have to be assumed or gotten from some
    --  # other source
    -- 
    -- 
    --  Header header                        # timestamp is the time the
    --                                       # field was measured
    --                                       # frame_id is the location and orientation
    --                                       # of the field measurement
    -- 
    --  geometry_msgs/Vector3 magnetic_field # x, y, and z components of the
    --                                       # field vector in Tesla
    --                                       # If your sensor does not output 3 axes,
    --                                       # put NaNs in the components not reported.
    -- 
    --  float64[9] magnetic_field_covariance # Row major about x, y, z axes
    --                                       # 0 is interpreted as variance unknown
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- 
    -- ================================================================================
    -- MSG: geometry_msgs/Vector3
    -- # This represents a vector in free space. 
    -- # It is only meant to represent a direction. Therefore, it does not
    -- # make sense to apply a translation to it (e.g., when applying a 
    -- # generic rigid transformation to a Vector3, tf2 will only apply the
    -- # rotation). If you want your data to be translatable too, use the
    -- # geometry_msgs/Point message instead.
    -- 
    -- float64 x
    -- float64 y
    -- float64 z    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/MagneticField
    Sensor-msgs-MagneticField ::= SEQUENCE
    {
        header Std-msgs-Header,
        magnetic-field Geometry-msgs-Vector3,
        magnetic-field-covariance SEQUENCE (SIZE(9)) OF T-Double
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/MultiDOFJointState
    -- ================================================================================
    -- # Representation of state for joints with multiple degrees of freedom, 
    -- # following the structure of JointState.
    -- #
    -- # It is assumed that a joint in a system corresponds to a transform that gets applied 
    -- # along the kinematic chain. For example, a planar joint (as in URDF) is 3DOF (x, y, yaw)
    -- # and those 3DOF can be expressed as a transformation matrix, and that transformation
    -- # matrix can be converted back to (x, y, yaw)
    -- #
    -- # Each joint is uniquely identified by its name
    -- # The header specifies the time at which the joint states were recorded. All the joint states
    -- # in one message have to be recorded at the same time.
    -- #
    -- # This message consists of a multiple arrays, one for each part of the joint state. 
    -- # The goal is to make each of the fields optional. When e.g. your joints have no
    -- # wrench associated with them, you can leave the wrench array empty. 
    -- #
    -- # All arrays in this message should have the same size, or be empty.
    -- # This is the only way to uniquely associate the joint name with the correct
    -- # states.
    -- 
    -- Header header
    -- 
    -- string[] joint_names
    -- geometry_msgs/Transform[] transforms
    -- geometry_msgs/Twist[] twist
    -- geometry_msgs/Wrench[] wrench
    -- 
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- 
    -- ================================================================================
    -- MSG: geometry_msgs/Transform
    -- # This represents the transform between two coordinate frames in free space.
    -- 
    -- Vector3 translation
    -- Quaternion rotation
    -- 
    -- ================================================================================
    -- MSG: geometry_msgs/Vector3
    -- # This represents a vector in free space. 
    -- # It is only meant to represent a direction. Therefore, it does not
    -- # make sense to apply a translation to it (e.g., when applying a 
    -- # generic rigid transformation to a Vector3, tf2 will only apply the
    -- # rotation). If you want your data to be translatable too, use the
    -- # geometry_msgs/Point message instead.
    -- 
    -- float64 x
    -- float64 y
    -- float64 z
    -- ================================================================================
    -- MSG: geometry_msgs/Quaternion
    -- # This represents an orientation in free space in quaternion form.
    -- 
    -- float64 x
    -- float64 y
    -- float64 z
    -- float64 w
    -- 
    -- ================================================================================
    -- MSG: geometry_msgs/Twist
    -- # This expresses velocity in free space broken into its linear and angular parts.
    -- Vector3  linear
    -- Vector3  angular
    -- 
    -- ================================================================================
    -- MSG: geometry_msgs/Wrench
    -- # This represents force in free space, separated into
    -- # its linear and angular parts.
    -- Vector3  force
    -- Vector3  torque
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/MultiDOFJointState
    Sensor-msgs-MultiDOFJointState ::= SEQUENCE
    {
        header Std-msgs-Header,
        joint-names SEQUENCE (SIZE(0..max-Sensor-msgs-MultiDOFJointState)) OF T-String,
        transforms SEQUENCE (SIZE(0..max-Sensor-msgs-MultiDOFJointState)) OF Geometry-msgs-Transform,
        twist SEQUENCE (SIZE(0..max-Sensor-msgs-MultiDOFJointState)) OF Geometry-msgs-Twist,
        wrench SEQUENCE (SIZE(0..max-Sensor-msgs-MultiDOFJointState)) OF Geometry-msgs-Wrench
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/MultiEchoLaserScan
    -- ================================================================================
    -- # Single scan from a multi-echo planar laser range-finder
    -- #
    -- # If you have another ranging device with different behavior (e.g. a sonar
    -- # array), please find or create a different message, since applications
    -- # will make fairly laser-specific assumptions about this data
    -- 
    -- Header header            # timestamp in the header is the acquisition time of 
    --                          # the first ray in the scan.
    --                          #
    --                          # in frame frame_id, angles are measured around 
    --                          # the positive Z axis (counterclockwise, if Z is up)
    --                          # with zero angle being forward along the x axis
    --                          
    -- float32 angle_min        # start angle of the scan [rad]
    -- float32 angle_max        # end angle of the scan [rad]
    -- float32 angle_increment  # angular distance between measurements [rad]
    -- 
    -- float32 time_increment   # time between measurements [seconds] - if your scanner
    --                          # is moving, this will be used in interpolating position
    --                          # of 3d points
    -- float32 scan_time        # time between scans [seconds]
    -- 
    -- float32 range_min        # minimum range value [m]
    -- float32 range_max        # maximum range value [m]
    -- 
    -- LaserEcho[] ranges       # range data [m] (Note: NaNs, values < range_min or > range_max should be discarded)
    --                          # +Inf measurements are out of range
    --                          # -Inf measurements are too close to determine exact distance.
    -- LaserEcho[] intensities  # intensity data [device-specific units].  If your
    --                          # device does not provide intensities, please leave
    --                          # the array empty.
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- 
    -- ================================================================================
    -- MSG: sensor_msgs/LaserEcho
    -- # This message is a submessage of MultiEchoLaserScan and is not intended
    -- # to be used separately.
    -- 
    -- float32[] echoes  # Multiple values of ranges or intensities.
    --                   # Each array represents data from the same angle increment.    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/MultiEchoLaserScan
    Sensor-msgs-MultiEchoLaserScan ::= SEQUENCE
    {
        header Std-msgs-Header,
        angle-min T-Float,
        angle-max T-Float,
        angle-increment T-Float,
        time-increment T-Float,
        scan-time T-Float,
        range-min T-Float,
        range-max T-Float,
        ranges SEQUENCE (SIZE(0..max-Sensor-msgs-MultiEchoLaserScan)) OF Sensor-msgs-LaserEcho,
        intensities SEQUENCE (SIZE(0..max-Sensor-msgs-MultiEchoLaserScan)) OF Sensor-msgs-LaserEcho
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/NavSatFix
    -- ================================================================================
    -- # Navigation Satellite fix for any Global Navigation Satellite System
    -- #
    -- # Specified using the WGS 84 reference ellipsoid
    -- 
    -- # header.stamp specifies the ROS time for this measurement (the
    -- #        corresponding satellite time may be reported using the
    -- #        sensor_msgs/TimeReference message).
    -- #
    -- # header.frame_id is the frame of reference reported by the satellite
    -- #        receiver, usually the location of the antenna.  This is a
    -- #        Euclidean frame relative to the vehicle, not a reference
    -- #        ellipsoid.
    -- Header header
    -- 
    -- # satellite fix status information
    -- NavSatStatus status
    -- 
    -- # Latitude [degrees]. Positive is north of equator; negative is south.
    -- float64 latitude
    -- 
    -- # Longitude [degrees]. Positive is east of prime meridian; negative is west.
    -- float64 longitude
    -- 
    -- # Altitude [m]. Positive is above the WGS 84 ellipsoid
    -- # (quiet NaN if no altitude is available).
    -- float64 altitude
    -- 
    -- # Position covariance [m^2] defined relative to a tangential plane
    -- # through the reported position. The components are East, North, and
    -- # Up (ENU), in row-major order.
    -- #
    -- # Beware: this coordinate system exhibits singularities at the poles.
    -- 
    -- float64[9] position_covariance
    -- 
    -- # If the covariance of the fix is known, fill it in completely. If the
    -- # GPS receiver provides the variance of each measurement, put them
    -- # along the diagonal. If only Dilution of Precision is available,
    -- # estimate an approximate covariance from that.
    -- 
    -- uint8 COVARIANCE_TYPE_UNKNOWN = 0
    -- uint8 COVARIANCE_TYPE_APPROXIMATED = 1
    -- uint8 COVARIANCE_TYPE_DIAGONAL_KNOWN = 2
    -- uint8 COVARIANCE_TYPE_KNOWN = 3
    -- 
    -- uint8 position_covariance_type
    -- 
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- 
    -- ================================================================================
    -- MSG: sensor_msgs/NavSatStatus
    -- # Navigation Satellite fix status for any Global Navigation Satellite System
    -- 
    -- # Whether to output an augmented fix is determined by both the fix
    -- # type and the last time differential corrections were received.  A
    -- # fix is valid when status >= STATUS_FIX.
    -- 
    -- int8 STATUS_NO_FIX =  -1        # unable to fix position
    -- int8 STATUS_FIX =      0        # unaugmented fix
    -- int8 STATUS_SBAS_FIX = 1        # with satellite-based augmentation
    -- int8 STATUS_GBAS_FIX = 2        # with ground-based augmentation
    -- 
    -- int8 status
    -- 
    -- # Bits defining which Global Navigation Satellite System signals were
    -- # used by the receiver.
    -- 
    -- uint16 SERVICE_GPS =     1
    -- uint16 SERVICE_GLONASS = 2
    -- uint16 SERVICE_COMPASS = 4      # includes BeiDou.
    -- uint16 SERVICE_GALILEO = 8
    -- 
    -- uint16 service
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/NavSatFix
    Sensor-msgs-NavSatFix ::= SEQUENCE
    {
        header Std-msgs-Header,
        status Sensor-msgs-NavSatStatus,
        latitude T-Double,
        longitude T-Double,
        altitude T-Double,
        position-covariance SEQUENCE (SIZE(9)) OF T-Double,
        position-covariance-type T-UInt8
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/NavSatStatus
    -- ================================================================================
    -- # Navigation Satellite fix status for any Global Navigation Satellite System
    -- 
    -- # Whether to output an augmented fix is determined by both the fix
    -- # type and the last time differential corrections were received.  A
    -- # fix is valid when status >= STATUS_FIX.
    -- 
    -- int8 STATUS_NO_FIX =  -1        # unable to fix position
    -- int8 STATUS_FIX =      0        # unaugmented fix
    -- int8 STATUS_SBAS_FIX = 1        # with satellite-based augmentation
    -- int8 STATUS_GBAS_FIX = 2        # with ground-based augmentation
    -- 
    -- int8 status
    -- 
    -- # Bits defining which Global Navigation Satellite System signals were
    -- # used by the receiver.
    -- 
    -- uint16 SERVICE_GPS =     1
    -- uint16 SERVICE_GLONASS = 2
    -- uint16 SERVICE_COMPASS = 4      # includes BeiDou.
    -- uint16 SERVICE_GALILEO = 8
    -- 
    -- uint16 service
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/NavSatStatus
    Sensor-msgs-NavSatStatus ::= SEQUENCE
    {
        status T-Int8,
        service-value T-UInt16
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/PointCloud
    -- ================================================================================
    -- # This message holds a collection of 3d points, plus optional additional
    -- # information about each point.
    -- 
    -- # Time of sensor data acquisition, coordinate frame ID.
    -- Header header
    -- 
    -- # Array of 3d points. Each Point32 should be interpreted as a 3d point
    -- # in the frame given in the header.
    -- geometry_msgs/Point32[] points
    -- 
    -- # Each channel should have the same number of elements as points array,
    -- # and the data in each channel should correspond 1:1 with each point.
    -- # Channel names in common practice are listed in ChannelFloat32.msg.
    -- ChannelFloat32[] channels
    -- 
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- 
    -- ================================================================================
    -- MSG: geometry_msgs/Point32
    -- # This contains the position of a point in free space(with 32 bits of precision).
    -- # It is recommeded to use Point wherever possible instead of Point32.  
    -- # 
    -- # This recommendation is to promote interoperability.  
    -- #
    -- # This message is designed to take up less space when sending
    -- # lots of points at once, as in the case of a PointCloud.  
    -- 
    -- float32 x
    -- float32 y
    -- float32 z
    -- ================================================================================
    -- MSG: sensor_msgs/ChannelFloat32
    -- # This message is used by the PointCloud message to hold optional data
    -- # associated with each point in the cloud. The length of the values
    -- # array should be the same as the length of the points array in the
    -- # PointCloud, and each value should be associated with the corresponding
    -- # point.
    -- 
    -- # Channel names in existing practice include:
    -- #   "u", "v" - row and column (respectively) in the left stereo image.
    -- #              This is opposite to usual conventions but remains for
    -- #              historical reasons. The newer PointCloud2 message has no
    -- #              such problem.
    -- #   "rgb" - For point clouds produced by color stereo cameras. uint8
    -- #           (R,G,B) values packed into the least significant 24 bits,
    -- #           in order.
    -- #   "intensity" - laser or pixel intensity.
    -- #   "distance"
    -- 
    -- # The channel name should give semantics of the channel (e.g.
    -- # "intensity" instead of "value").
    -- string name
    -- 
    -- # The values array should be 1-1 with the elements of the associated
    -- # PointCloud.
    -- float32[] values
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/PointCloud
    Sensor-msgs-PointCloud ::= SEQUENCE
    {
        header Std-msgs-Header,
        points SEQUENCE (SIZE(0..max-Sensor-msgs-PointCloud)) OF Geometry-msgs-Point32,
        channels SEQUENCE (SIZE(0..max-Sensor-msgs-PointCloud)) OF Sensor-msgs-ChannelFloat32
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/PointCloud2
    -- ================================================================================
    -- # This message holds a collection of N-dimensional points, which may
    -- # contain additional information such as normals, intensity, etc. The
    -- # point data is stored as a binary blob, its layout described by the
    -- # contents of the "fields" array.
    -- 
    -- # The point cloud data may be organized 2d (image-like) or 1d
    -- # (unordered). Point clouds organized as 2d images may be produced by
    -- # camera depth sensors such as stereo or time-of-flight.
    -- 
    -- # Time of sensor data acquisition, and the coordinate frame ID (for 3d
    -- # points).
    -- Header header
    -- 
    -- # 2D structure of the point cloud. If the cloud is unordered, height is
    -- # 1 and width is the length of the point cloud.
    -- uint32 height
    -- uint32 width
    -- 
    -- # Describes the channels and their layout in the binary data blob.
    -- PointField[] fields
    -- 
    -- bool    is_bigendian # Is this data bigendian?
    -- uint32  point_step   # Length of a point in bytes
    -- uint32  row_step     # Length of a row in bytes
    -- uint8[] data         # Actual point data, size is (row_step*height)
    -- 
    -- bool is_dense        # True if there are no invalid points
    -- 
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- 
    -- ================================================================================
    -- MSG: sensor_msgs/PointField
    -- # This message holds the description of one point entry in the
    -- # PointCloud2 message format.
    -- uint8 INT8    = 1
    -- uint8 UINT8   = 2
    -- uint8 INT16   = 3
    -- uint8 UINT16  = 4
    -- uint8 INT32   = 5
    -- uint8 UINT32  = 6
    -- uint8 FLOAT32 = 7
    -- uint8 FLOAT64 = 8
    -- 
    -- string name      # Name of field
    -- uint32 offset    # Offset from start of point struct
    -- uint8  datatype  # Datatype enumeration, see above
    -- uint32 count     # How many elements in the field
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/PointCloud2
    Sensor-msgs-PointCloud2 ::= SEQUENCE
    {
        header Std-msgs-Header,
        height T-UInt32,
        width T-UInt32,
        fields SEQUENCE (SIZE(0..max-Sensor-msgs-PointCloud2)) OF Sensor-msgs-PointField,
        is-bigendian T-Boolean,
        point-step T-UInt32,
        row-step T-UInt32,
        data-value OCTET STRING (SIZE(0..max-Sensor-msgs-PointCloud2)),
        is-dense T-Boolean
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/PointField
    -- ================================================================================
    -- # This message holds the description of one point entry in the
    -- # PointCloud2 message format.
    -- uint8 INT8    = 1
    -- uint8 UINT8   = 2
    -- uint8 INT16   = 3
    -- uint8 UINT16  = 4
    -- uint8 INT32   = 5
    -- uint8 UINT32  = 6
    -- uint8 FLOAT32 = 7
    -- uint8 FLOAT64 = 8
    -- 
    -- string name      # Name of field
    -- uint32 offset    # Offset from start of point struct
    -- uint8  datatype  # Datatype enumeration, see above
    -- uint32 count     # How many elements in the field
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/PointField
    Sensor-msgs-PointField ::= SEQUENCE
    {
        name-value T-String,
        offset T-UInt32,
        datatype T-UInt8,
        count T-UInt32
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/Range
    -- ================================================================================
    -- # Single range reading from an active ranger that emits energy and reports
    -- # one range reading that is valid along an arc at the distance measured. 
    -- # This message is  not appropriate for laser scanners. See the LaserScan
    -- # message if you are working with a laser scanner.
    -- 
    -- # This message also can represent a fixed-distance (binary) ranger.  This
    -- # sensor will have min_range===max_range===distance of detection.
    -- # These sensors follow REP 117 and will output -Inf if the object is detected
    -- # and +Inf if the object is outside of the detection range.
    -- 
    -- Header header           # timestamp in the header is the time the ranger
    --                         # returned the distance reading
    -- 
    -- # Radiation type enums
    -- # If you want a value added to this list, send an email to the ros-users list
    -- uint8 ULTRASOUND=0
    -- uint8 INFRARED=1
    -- 
    -- uint8 radiation_type    # the type of radiation used by the sensor
    --                         # (sound, IR, etc) [enum]
    -- 
    -- float32 field_of_view   # the size of the arc that the distance reading is
    --                         # valid for [rad]
    --                         # the object causing the range reading may have
    --                         # been anywhere within -field_of_view/2 and
    --                         # field_of_view/2 at the measured range. 
    --                         # 0 angle corresponds to the x-axis of the sensor.
    -- 
    -- float32 min_range       # minimum range value [m]
    -- float32 max_range       # maximum range value [m]
    --                         # Fixed distance rangers require min_range==max_range
    -- 
    -- float32 range           # range data [m]
    --                         # (Note: values < range_min or > range_max
    --                         # should be discarded)
    --                         # Fixed distance rangers only output -Inf or +Inf.
    --                         # -Inf represents a detection within fixed distance.
    --                         # (Detection too close to the sensor to quantify)
    --                         # +Inf represents no detection within the fixed distance.
    --                         # (Object out of range)
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/Range
    Sensor-msgs-Range ::= SEQUENCE
    {
        header Std-msgs-Header,
        radiation-type T-UInt8,
        field-of-view T-Float,
        min-range T-Float,
        max-range T-Float,
        range-value T-Float
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/RegionOfInterest
    -- ================================================================================
    -- # This message is used to specify a region of interest within an image.
    -- #
    -- # When used to specify the ROI setting of the camera when the image was
    -- # taken, the height and width fields should either match the height and
    -- # width fields for the associated image; or height = width = 0
    -- # indicates that the full resolution image was captured.
    -- 
    -- uint32 x_offset  # Leftmost pixel of the ROI
    --                  # (0 if the ROI includes the left edge of the image)
    -- uint32 y_offset  # Topmost pixel of the ROI
    --                  # (0 if the ROI includes the top edge of the image)
    -- uint32 height    # Height of ROI
    -- uint32 width     # Width of ROI
    -- 
    -- # True if a distinct rectified ROI should be calculated from the "raw"
    -- # ROI in this message. Typically this should be False if the full image
    -- # is captured (ROI not used), and True if a subwindow is captured (ROI
    -- # used).
    -- bool do_rectify
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/RegionOfInterest
    Sensor-msgs-RegionOfInterest ::= SEQUENCE
    {
        x-offset T-UInt32,
        y-offset T-UInt32,
        height T-UInt32,
        width T-UInt32,
        do-rectify T-Boolean
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/RelativeHumidity
    -- ================================================================================
    --  # Single reading from a relative humidity sensor.  Defines the ratio of partial
    --  # pressure of water vapor to the saturated vapor pressure at a temperature.
    -- 
    --  Header header             # timestamp of the measurement
    --                            # frame_id is the location of the humidity sensor
    -- 
    --  float64 relative_humidity # Expression of the relative humidity
    --                            # from 0.0 to 1.0.
    --                            # 0.0 is no partial pressure of water vapor
    --                            # 1.0 represents partial pressure of saturation
    -- 
    --  float64 variance          # 0 is interpreted as variance unknown
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/RelativeHumidity
    Sensor-msgs-RelativeHumidity ::= SEQUENCE
    {
        header Std-msgs-Header,
        relative-humidity T-Double,
        variance T-Double
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/Temperature
    -- ================================================================================
    --  # Single temperature reading.
    -- 
    --  Header header           # timestamp is the time the temperature was measured
    --                          # frame_id is the location of the temperature reading
    -- 
    --  float64 temperature     # Measurement of the Temperature in Degrees Celsius
    -- 
    --  float64 variance        # 0 is interpreted as variance unknown
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/Temperature
    Sensor-msgs-Temperature ::= SEQUENCE
    {
        header Std-msgs-Header,
        temperature T-Double,
        variance T-Double
    }
    -- ================================================================================

    -- ================================================================================
    -- Message Sensor-msgs-Types/TimeReference
    -- ================================================================================
    -- # Measurement from an external time source not actively synchronized with the system clock.
    -- 
    -- Header header    # stamp is system time for which measurement was valid
    --                  # frame_id is not used 
    -- 
    -- time   time_ref  # corresponding time from this external source
    -- string source    # (optional) name of time source
    -- 
    -- ================================================================================
    -- MSG: std_msgs/Header
    -- # Standard metadata for higher-level stamped data types.
    -- # This is generally used to communicate timestamped data 
    -- # in a particular coordinate frame.
    -- # 
    -- # sequence ID: consecutively increasing ID 
    -- uint32 seq
    -- #Two-integer timestamp that is expressed as:
    -- # * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
    -- # * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
    -- # time-handling sugar is provided by the client library
    -- time stamp
    -- #Frame this data is associated with
    -- # 0: no frame
    -- # 1: global frame
    -- string frame_id
    -- ================================================================================
    -- ASN.1 type for Sensor-msgs-Types/TimeReference
    Sensor-msgs-TimeReference ::= SEQUENCE
    {
        header Std-msgs-Header,
        time-ref T-Time,
        source T-String
    }
    -- ================================================================================

END
